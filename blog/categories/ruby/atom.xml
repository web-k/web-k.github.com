<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | web-k.log]]></title>
  <link href="http://web-k.github.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://web-k.github.com/"/>
  <updated>2013-01-25T11:49:22+09:00</updated>
  <id>http://web-k.github.com/</id>
  <author>
    <name><![CDATA[Team web-k]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[refinements]]></title>
    <link href="http://web-k.github.com/blog/2013/01/21/ruby-refinements/"/>
    <updated>2013-01-21T14:06:00+09:00</updated>
    <id>http://web-k.github.com/blog/2013/01/21/ruby-refinements</id>
    <content type="html"><![CDATA[<p>ruby 2.0.0の主な機能のうちのひとつ「Refinements」の挙動について。</p>

<h3>Refinementsとは</h3>

<p>既存のクラスの挙動を変更したり、拡張するときの影響範囲を名前空間で限定する機能です。
これまでも既存のクラスやメソッドに対する、動的な挙動の変更や追加は可能でしたが、以下のような問題もありました。</p>

<ul>
<li>プログラム全体に影響を与えてしまう</li>
<li>変更が見えにくい</li>
</ul>


<p>モンキーパッチをモジュールとして分割してincludeするなどして、
明示的にするなどの対処法はとられてきましたが、
refinmentsは書き換えをより厳密で局所的なものにとどめるものになっています。</p>

<p>例としてStringクラスに局所的にメソッドを追加するコードを示します。
```ruby
module HogeExtension
  refine String do</p>

<pre><code>def to_camelcase
  split('_').map{|s| s.capitalize}.join('')
end
</code></pre>

<p>  end
end</p>

<p>class RefineTest
  using HogeExtension</p>

<p>  def initialize</p>

<pre><code>p 'aaa_bbb_ccc'.to_camelcase
</code></pre>

<p>  end
end</p>

<p>RefineTest.new               # => "AaaBbbCcc"
p 'aaa_bbb_ccc'.to_camelcase # => NoMethodError
```
HogeExtensionモジュールでは、Stringクラスに対するto_calmelcaseメソッドの追加をrefineキーワードで行なっています。
この実装は、HogeExtensionモジュールをusingキーワードでとりこんだRefineTestクラスでは適用されるので、利用できます。
しかし、それ以外の部分でStringクラスのインスタンスに対しては、利用できないことがわかります。</p>

<h3>スコープ</h3>

<p>refinementsは厳密なレキシカルスコープ(内部で定義した変数は外から見えないが、その逆は可能というスコープ)で動きます。
つまり、usingしたスコープと違うスコープに対しては、適用されません。
また、外側よりは内部の、前のよりは後の方が優先度が高く適用されます。
```ruby
module HogeExtension
  refine String do</p>

<pre><code>def plus_string
  p self + ' hoge'
end 
</code></pre>

<p>  end
end</p>

<p>module FugaExtension
  refine String do</p>

<pre><code>def plus_string
  p self + ' fuga'
end 
</code></pre>

<p>  end
end</p>

<p>class RefineTest
  using HogeExtension
  'outer1'.plus_string   # => "outer1 hoge"</p>

<p>  class Inner</p>

<pre><code>using FugaExtension
'inner1'.plus_string # =&gt; "inner1 fuga"
</code></pre>

<p>  end</p>

<p>  'outer2'.plus_string   # => "outer2 hoge"</p>

<p>  using FugaExtension
  'outer3'.plus_string   # => "outer3 fuga"
end</p>

<h1>拡張クラス内でも有効</h1>

<p>class RefineTestEx &lt; RefineTest
  'test'.plus_string     # => "test fuga"
end
```</p>

<h3>モジュールには適用できない</h3>

<p>モジュールのメソッドにはrefinementsを適用できません。
<code>ruby
module EnumerableExt
  # エラー!
  refine Enumerable do
  end
end
</code></p>

<h3>SelectorNamespcaceである</h3>

<p>これはちょっとややこしいので、例を示します。
```ruby
class Hoge
  def say_hoge</p>

<pre><code>puts 'hoge'
</code></pre>

<p>  end</p>

<p>  def introduce</p>

<pre><code>print 'This is '
say_hoge
</code></pre>

<p>  end
end</p>

<p>instance = Hoge.new
instance.say_hoge  # => 'hoge'
instance.introduce # => 'This is hoge'</p>

<p>module HogeExtension
  refine Hoge do</p>

<pre><code>def say_hoge
  puts 'fuga'
end
</code></pre>

<p>  end
end</p>

<p>using HogeExtension
instance.say_hoge  # => 'fuga'
instance.introduce # => 'This is hoge'
```
26行目のintroduceに注目。
intstanceのintroduceが呼ぶのは元のAクラスのsay_hogeメソッドですので、'fuga'ではなく'hoge'の方が画面に出力されます。
これは、refinementsがレキシカルスコープで動くことの証拠です。
Aのintroduceメソッドは、それとは違うスコープで適用されたrefinementsの影響を受けません。
このような挙動をSelectorNamespcace と呼ぶそうです。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[%i: シンボルの配列のリテラル]]></title>
    <link href="http://web-k.github.com/blog/2013/01/17/ruby-percent-i/"/>
    <updated>2013-01-17T15:59:00+09:00</updated>
    <id>http://web-k.github.com/blog/2013/01/17/ruby-percent-i</id>
    <content type="html"><![CDATA[<p>Ruby 2.0.0の主な機能のうちのひとつ「%i」の挙動について。</p>

<p>シンボルの配列がリテラルで書けるようになった。
<code>ruby
%i[hoge fuga] # =&gt; [:hoge, :fuga]
</code>
ちなみに文字列の配列のリテラルは以下のようにする。(これは以前からあった)
<code>ruby
%w[hoge fuga] # =&gt; ["hoge", "fuga"]
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Module#prepend]]></title>
    <link href="http://web-k.github.com/blog/2013/01/17/ruby-prepend/"/>
    <updated>2013-01-17T15:48:00+09:00</updated>
    <id>http://web-k.github.com/blog/2013/01/17/ruby-prepend</id>
    <content type="html"><![CDATA[<p>Ruby 2.0.0の主な機能のうちのひとつ「Module#prepend」の挙動について。</p>

<p>prependは呼び出し元のクラス/モジュールの前にモジュールを置きます。
その呼ばれたモジュールの中で同じ名前を持つメソッドがあれば、それをラップします。
局所的なモンキーパッチを当てるような感じです。
```ruby
module Foo
  def foo</p>

<pre><code>p "before"
super
p "after"
</code></pre>

<p>  end
end</p>

<p>class Bar
  def foo</p>

<pre><code>p "bar"
</code></pre>

<p>  end
  prepend Foo
end</p>

<p>Bar.new.foo # "before", "bar", "after"
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby 2.0 キーワード引数]]></title>
    <link href="http://web-k.github.com/blog/2013/01/17/ruby-keyword-arguments/"/>
    <updated>2013-01-17T15:00:00+09:00</updated>
    <id>http://web-k.github.com/blog/2013/01/17/ruby-keyword-arguments</id>
    <content type="html"><![CDATA[<p>Ruby 2.0.0の主な機能のうちのひとつ「キーワード引数」の挙動について。</p>

<p>キーワード引数はメソッドのそれぞれの引数にその意味を示すキーワードを付与し、キーワードを通じて引数を渡せる機能です。
```ruby
def my_method(str: "hoge", num: 1)
  [str, num]
end</p>

<h1>実行結果</h1>

<p>my_method # => ["hoge", 1]
my_method(str: "fuga") # => ["fuga", 1]
my_method(num: 2) # => ["hoge", 2]
my_method(strrr: "huga") # => ArgumentError: unknown keyword: strrr
```
実行時キーワード省略でデフォルト値が利用され、キーワード指定すると指定したものだけ値が書き換えられる。
引数全てを渡さなくてもよいというのも嬉しい。
定義されていないキーワードを指定すると当然ながらエラーとなる。</p>
]]></content>
  </entry>
  
</feed>
